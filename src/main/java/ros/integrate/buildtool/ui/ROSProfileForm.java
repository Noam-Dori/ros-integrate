package ros.integrate.buildtool.ui;

import com.intellij.openapi.project.Project;
import com.intellij.openapi.ui.ComboBox;
import com.intellij.ui.DocumentAdapter;
import com.intellij.ui.components.JBCheckBox;
import com.intellij.ui.components.JBLabel;
import com.intellij.ui.components.JBTextField;
import com.intellij.ui.components.fields.ExpandableTextField;
import org.jetbrains.annotations.NotNull;
import ros.integrate.buildtool.ROSBuildTool;
import ros.integrate.buildtool.ROSProfile;
import ros.integrate.ui.BrowserOptions;
import ros.integrate.ui.BrowserOptions.HistoryKey;
import ros.integrate.ui.PathTextFieldWithHistory;
import ros.integrate.ui.SectionedFormBuilder;

import javax.swing.*;
import javax.swing.event.DocumentEvent;
import java.awt.*;
import java.util.stream.Stream;

/**
 * the GUI component that allows editing details about a specific profile while remaining
 * detached from the data component (until the user specifically requests so)
 * @author Noam Dori
 */
public class ROSProfileForm {
    @NotNull
    private final JPanel panel;

    private final JBLabel buildtoolArgsLabel = new JBLabel("<html><code>Buildtool</code> args:</html>");

    private static int getMaxBuildtoolSize() {
        int explicitSize = Stream.of(ROSBuildTool.values()).map(Enum::name)
                .map(String::length)
                .max(Integer::compare).orElse(0);
        return Math.max(explicitSize, 9);
    }

    private final JBTextField name = new FocusTextField();
    private final ComboBox<ROSBuildTool> buildtool = new ComboBox<>(ROSBuildTool.values());
    private final JBCheckBox doInstall = new JBCheckBox("Run install step");
    private final ComboBox<Boolean> doIsolation = new ComboBox<>(new Boolean[]{true, false});
    private final ExpandableTextField makeArgs = new ExpandableTextField(), cmakeArgs = new ExpandableTextField(),
            buildtoolArgs = new ExpandableTextField();

    private final PathTextFieldWithHistory sourceDir = new PathTextFieldWithHistory(),
            buildDir = new PathTextFieldWithHistory(),
            develDir = new PathTextFieldWithHistory(),
            installDir = new PathTextFieldWithHistory();

    public ROSProfileForm(@NotNull Project project) {
        JBLabel nameLabel = new JBLabel("Name:");
        JBLabel buildtoolLabel = new JBLabel("Build tool:");
        JBLabel isolationLabel = new JBLabel("Build layout:");
        JBLabel makeArgsLabel = new JBLabel("<html><code>Make</code> args:</html>");
        JBLabel cmakeArgsLabel = new JBLabel("<html><code>CMake</code> args:</html>");
        JBLabel sourceDirLabel = new JBLabel("Source directory:");
        JBLabel buildDirLabel = new JBLabel("Build directory:");
        JBLabel develDirLabel = new JBLabel("Devel directory:");
        JBLabel installDirLabel = new JBLabel("Install directory:");

        sourceDir.installFeatures(new BrowserOptions(project, HistoryKey.PROFILE_SOURCE)
                .withTitle("Choose source directory")
                .withDescription("The directory containing all sources"));
        buildDir.installFeatures(new BrowserOptions(project, HistoryKey.PROFILE_BUILD)
                .withTitle("Choose build directory")
                .withDescription("The directory containing all files generated by CMake, the compiler, and linker"));
        develDir.installFeatures(new BrowserOptions(project, HistoryKey.PROFILE_DEVEL)
                .withTitle("Choose devel directory")
                .withDescription("The directory containing the result files created by the build process"));
        installDir.installFeatures(new BrowserOptions(project, HistoryKey.PROFILE_INSTALL)
                .withTitle("Choose build directory")
                .withDescription("The directory containing the final output exposed to the client"));

        buildtool.setEditable(false);
        buildtool.setRenderer(new DefaultListCellRenderer() {
            @Override
            public JLabel getListCellRendererComponent(JList<?> list, Object value, int index,
                                                          boolean isSelected, boolean cellHasFocus) {
                JLabel ret = (JLabel) super.getListCellRendererComponent(list, value.toString().toLowerCase(),
                        index, isSelected, cellHasFocus);
                ret.setIcon(ROSBuildTool.valueOf(value.toString()).getIcon());
                return ret;
            }
        });

        doIsolation.setEditable(false);
        doIsolation.setRenderer(new DefaultListCellRenderer() {
            @Override
            public Component getListCellRendererComponent(JList<?> list, Object value, int index,
                                                          boolean isSelected, boolean cellHasFocus) {
                String toRender = (Boolean) value ? "Isolated" : "Merged";
                return super.getListCellRendererComponent(list, toRender,
                        index, isSelected, cellHasFocus);
            }
        });
        buildtool.addItemListener(event -> {
            if (buildtool.getItem() == ROSBuildTool.CATKIN_MAKE) {
                doIsolation.setEnabled(true);
            }
            else {
                doIsolation.setEnabled(false);
                doIsolation.setSelectedItem(true);
            }
            String buildtoolName = buildtool.getItem().name().toLowerCase();
            buildtoolArgsLabel.setText(String.format("<html><code>%s</code> args:</html>", buildtoolName));
        });

        panel = SectionedFormBuilder.createFormBuilder()
                .addLabeledComponent(nameLabel, name)
                .addSection(null)
                .addLabeledComponent(buildtoolLabel, buildtool)
                .addComponent(doInstall)
                .addLabeledComponent(isolationLabel, doIsolation)
                .closeSection().addSection("Build arguments")
                .addLabeledComponent(cmakeArgsLabel, cmakeArgs)
                .addLabeledComponent(buildtoolArgsLabel, buildtoolArgs)
                .addLabeledComponent(makeArgsLabel, makeArgs)
                .closeSection().addSection("Target directories")
                .addLabeledComponent(sourceDirLabel, sourceDir)
                .addLabeledComponent(buildDirLabel, buildDir)
                .addLabeledComponent(develDirLabel, develDir)
                .addLabeledComponent(installDirLabel, installDir)
                .closeSection()
                .getPanel();
    }

    @NotNull
    public JPanel getPanel() {
        return panel;
    }

    public void loadData(@NotNull ROSProfile profile, Runnable update) {
        name.setText(profile.getName());
        buildtool.setItem(profile.getBuildtool());
        doInstall.setSelected(profile.isInstall());
        doIsolation.setSelectedItem(profile.getIsolation());
        makeArgs.setText(profile.getMakeArgs());
        cmakeArgs.setText(profile.getCmakeArgs());
        buildtoolArgs.setText(profile.getBuildtoolArgs());
        sourceDir.setText(profile.getSourceDirectory());
        buildDir.setText(profile.getBuildDirectory());
        develDir.setText(profile.getDevelDirectory());
        installDir.setText(profile.getInstallDirectory());

        name.getDocument().addDocumentListener(new DocumentAdapter() {
            @Override
            protected void textChanged(@NotNull DocumentEvent e) {
                profile.setGuiName(name.getText());
                update.run();
            }
        });

        buildtool.addItemListener(event -> {
            profile.setGuiBuildtool(buildtool.getItem());
            update.run();
        });
    }
}
